## 13-roman-to-integer

### 問題のポイント

* **辞書（ハッシュマップ）の活用**: ローマ数字の記号と値のペアを辞書（`roman_map`）に格納することで、各文字の数値を $O(1)$ で高速に取得できる。
* **右隣の文字との比較ロジック**: 「現在の文字の値が次の文字の値よりも小さい場合は引き算、それ以外は足し算」というシンプルな一貫したルールで、特殊なケース（IV, IX, XL等）を網羅できる。
* **インデックスの境界チェック**: ループ内で `i + 1` 番目の要素（次の文字）を参照するため、文字列の末尾で範囲外アクセスをしないよう `i + 1 < n` の条件判定が不可欠。

### 計算量

* **時間計算量**: $O(n)$
    * 文字列の長さ $n$ に対して、左から右へ1回走査するだけなので、文字数に比例した時間で完了する。
* **空間計算量**: $O(1)$ 
    * 記号を格納する辞書のサイズは固定（7種類）であり、入力文字列の長さに依存せず、追加で使用する変数もわずかであるため。

### 所感

* ローマ数字には「4」や「9」といった例外ルールがあるため難しく感じたが、**「次の要素と比較して条件分岐する」**というアルゴリズムに落とし込むことで、非常に簡潔なコードになることに驚いた。
* 文字列を1文字ずつ処理する際、常に「次は何かな？」と1歩先を意識するテクニックは、構文解析やデータのバリデーションなど、多くの場面で応用できそう。
* 逆変換（整数からローマ数字）についても検討したことで、**「大きい単位から順に処理する（欲張り法 / Greedy Algorithm）」**という考え方に触れられ、数値操作への理解がより深まった。